{"version":3,"sources":["../../../app/helpers/index.js"],"names":["crypto","require","db","findOne","userModel","profileID","createNewUser","Promise","resolve","reject","newChatUser","profileId","profile","id","fullName","displayName","profilePic","photos","value","save","error","findById","user","isAuthenticated","req","res","next","redirect","findRoomByName","allrooms","room","findRoom","findIndex","element","index","array","findRoomById","roomID","find","randomHex","randomBytes","toString","addUserToRoom","data","socket","getRoom","undefined","userID","request","session","passport","checkUser","users","splice","push","socketID","userPic","join","removeUserFromRoom","findUser","length","leave","module","exports"],"mappings":"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","file":"index.js","sourcesContent":["const crypto = require(\"crypto\");\nconst db = require(\"../db\");\n\n// find a single doc\nlet findOne = profileID => {\n    return db.userModel.findOne({\n        \"profileId\": profileID\n    })\n};\n\n//  create a new user and return that instance\nlet createNewUser = profile => {\n    return new Promise((resolve, reject) => {\n        let newChatUser = new db.userModel({\n            profileId: profile.id,\n            fullName: profile.displayName,\n            profilePic: profile.photos[0].value || \"\"\n        });\n\n        newChatUser.save(error => {\n            if (error) {\n                reject(error);\n            } else {\n                resolve(newChatUser);\n            }\n        })\n    })\n};\n\n// findbyID\nlet findById = id => {\n    return new Promise((resolve, reject) => {\n        db.userModel.findById(id, (error, user) => {\n            if (error) {\n                reject(error);\n            } else {\n                resolve(user);\n            }\n        })\n    })\n};\n\n// authentication verification\nlet isAuthenticated = (req, res, next) => {\n    if (req.isAuthenticated()){\n        next();\n    } else {\n        res.redirect(\"/\");\n    }\n};\n\n// find a chatroom by name\nlet findRoomByName = (allrooms, room) => {\n    let findRoom = allrooms.findIndex((element, index, array) => {\n        return element.room === room;\n    });\n    return findRoom > -1;\n};\n\n// find a chatroom by Id\nlet findRoomById = (allrooms, roomID) => {\n    return allrooms.find((element, index, array) => {\n        return element.roomID === roomID;\n    });\n};\n\n// generate a unique room id\nlet randomHex = () => {\n    return crypto.randomBytes(24).toString(\"hex\");\n};\n\n// Add user to a chatroom\nlet addUserToRoom = (allrooms, data, socket) => {\n    // get the room object\n    let getRoom = findRoomById(allrooms, data.roomID);\n    if(getRoom !== undefined){\n        // get the active user's ID\n        let userID = socket.request.session.passport.user;\n        // check to see if this user already exists in room\n        let checkUser = getRoom.users.findIndex((element, index, array) => {\n            return element.userID === userID;\n        });\n        // if user already in room, remove him first\n        if(checkUser > -1) {\n            getRoom.users.splice(checkUser, 1);\n        }\n        // push the user into the rooms users array\n        getRoom.users.push({\n            socketID: socket.id,\n            userID,\n            user: data.user,\n            userPic: data.userPic\n        });\n        // join the room channel\n        socket.join(data.roomID);\n        // return the updated room object\n        return getRoom;\n    }\n};\n\n// Find and purge the user when a socket disconnects\nlet removeUserFromRoom = (allrooms, socket) => {\n    for(let room of allrooms) {\n        // find user\n        let findUser = room.users.findIndex((element, index, array) => {\n            return element.socketID === socket.id;\n        });\n\n        if (findUser > -1 && room.users.length > 1) {\n            socket.leave(room.roomID);\n            room.users.splice(findUser, 1);\n            return room;\n        } else {\n            socket.leave(room.roomID);\n            room.users.splice(findUser, 1);\n            allrooms.splice(room,1);\n        }\n    }\n};\n\n\n\nmodule.exports = {\n    findOne,\n    createNewUser,\n    findById,\n    isAuthenticated,\n    findRoomByName,\n    randomHex,\n    findRoomById,\n    addUserToRoom,\n    removeUserFromRoom\n};"]}