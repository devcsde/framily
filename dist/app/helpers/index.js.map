{"version":3,"sources":["../../../app/helpers/index.js"],"names":["crypto","require","db","findOne","userModel","profileID","createNewUser","Promise","resolve","reject","newChatUser","profileId","profile","id","fullName","displayName","profilePic","photos","value","save","error","findById","user","isAuthenticated","req","res","next","redirect","findRoomByName","allrooms","room","findRoom","findIndex","element","index","array","findRoomById","roomID","find","randomHex","randomBytes","toString","addUserToRoom","data","socket","getRoom","undefined","userID","request","session","passport","checkUser","users","splice","push","socketID","userPic","join","removeUserFromRoom","findUser","length","leave","module","exports"],"mappings":"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","file":"index.js","sourcesContent":["const crypto = require(\"crypto\");\r\nconst db = require(\"../db\");\r\n\r\n// find a single doc\r\nlet findOne = profileID => {\r\n    return db.userModel.findOne({\r\n        \"profileId\": profileID\r\n    })\r\n};\r\n\r\n//  create a new user and return that instance\r\nlet createNewUser = profile => {\r\n    return new Promise((resolve, reject) => {\r\n        let newChatUser = new db.userModel({\r\n            profileId: profile.id,\r\n            fullName: profile.displayName,\r\n            profilePic: profile.photos[0].value || \"\"\r\n        });\r\n\r\n        newChatUser.save(error => {\r\n            if (error) {\r\n                reject(error);\r\n            } else {\r\n                resolve(newChatUser);\r\n            }\r\n        })\r\n    })\r\n};\r\n\r\n// findbyID\r\nlet findById = id => {\r\n    return new Promise((resolve, reject) => {\r\n        db.userModel.findById(id, (error, user) => {\r\n            if (error) {\r\n                reject(error);\r\n            } else {\r\n                resolve(user);\r\n            }\r\n        })\r\n    })\r\n};\r\n\r\n// authentication verification\r\nlet isAuthenticated = (req, res, next) => {\r\n    if (req.isAuthenticated()){\r\n        next();\r\n    } else {\r\n        res.redirect(\"/\");\r\n    }\r\n};\r\n\r\n// find a chatroom by name\r\nlet findRoomByName = (allrooms, room) => {\r\n    let findRoom = allrooms.findIndex((element, index, array) => {\r\n        return element.room === room;\r\n    });\r\n    return findRoom > -1;\r\n};\r\n\r\n// find a chatroom by Id\r\nlet findRoomById = (allrooms, roomID) => {\r\n    return allrooms.find((element, index, array) => {\r\n        return element.roomID === roomID;\r\n    });\r\n};\r\n\r\n// generate a unique room id\r\nlet randomHex = () => {\r\n    return crypto.randomBytes(24).toString(\"hex\");\r\n};\r\n\r\n// Add user to a chatroom\r\nlet addUserToRoom = (allrooms, data, socket) => {\r\n    // get the room object\r\n    let getRoom = findRoomById(allrooms, data.roomID);\r\n    if(getRoom !== undefined){\r\n        // get the active user's ID\r\n        let userID = socket.request.session.passport.user;\r\n        // check to see if this user already exists in room\r\n        let checkUser = getRoom.users.findIndex((element, index, array) => {\r\n            return element.userID === userID;\r\n        });\r\n        // if user already in room, remove him first\r\n        if(checkUser > -1) {\r\n            getRoom.users.splice(checkUser, 1);\r\n        }\r\n        // push the user into the rooms users array\r\n        getRoom.users.push({\r\n            socketID: socket.id,\r\n            userID,\r\n            user: data.user,\r\n            userPic: data.userPic\r\n        });\r\n        // join the room channel\r\n        socket.join(data.roomID);\r\n        // return the updated room object\r\n        return getRoom;\r\n    }\r\n};\r\n\r\n// Find and purge the user when a socket disconnects\r\nlet removeUserFromRoom = (allrooms, socket) => {\r\n    for(let room of allrooms) {\r\n        // find user\r\n        let findUser = room.users.findIndex((element, index, array) => {\r\n            return element.socketID === socket.id;\r\n        });\r\n\r\n        if (findUser > -1 && room.users.length > 1) {\r\n            socket.leave(room.roomID);\r\n            room.users.splice(findUser, 1);\r\n            return room;\r\n        } else {\r\n            socket.leave(room.roomID);\r\n            room.users.splice(findUser, 1);\r\n            allrooms.splice(room,1);\r\n        }\r\n    }\r\n};\r\n\r\n\r\n\r\nmodule.exports = {\r\n    findOne,\r\n    createNewUser,\r\n    findById,\r\n    isAuthenticated,\r\n    findRoomByName,\r\n    randomHex,\r\n    findRoomById,\r\n    addUserToRoom,\r\n    removeUserFromRoom\r\n};"]}